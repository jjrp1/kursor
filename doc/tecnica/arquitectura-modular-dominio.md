# Arquitectura Modular del Dominio: Estrategia de Dise√±o para Tipos de Preguntas

## Resumen Ejecutivo

Este documento presenta el an√°lisis arquitect√≥nico y la decisi√≥n de dise√±o adoptada para la organizaci√≥n de las clases del dominio relacionadas con los diferentes tipos de preguntas en el sistema Kursor. Se eval√∫an dos enfoques principales y se justifica la elecci√≥n de una arquitectura modular basada en principios SOLID y patrones de dise√±o establecidos.

**Estado Actual:** ‚úÖ **IMPLEMENTADO** - La arquitectura modular ha sido completamente implementada y est√° en producci√≥n.

## Contexto del Problema

El sistema Kursor debe soportar m√∫ltiples tipos de preguntas (test, verdadero/falso, completar huecos, flashcards, etc.) que comparten caracter√≠sticas comunes pero presentan comportamientos espec√≠ficos. La cuesti√≥n arquitect√≥nica fundamental es determinar d√≥nde ubicar las clases hijas de `Pregunta`:

- **Opci√≥n 1**:  
  Centralizar todas las clases *hija* que heredan de *Pregunta* dentro del *modelo de dominio* dentro del paquete `com.kursor.core.domain`

- **Opci√≥n 2**:  
  Distribuir cada tipo (cada clase *hija*  que hereda de *Pregunta*) dentro del m√≥dulo correspondiente que implementa sus peculiaridades.

## An√°lisis de Opciones

### Opci√≥n 1: ***Dominio Centralizado***

#### Caracter√≠sticas
- Todas las clases hijas de `Pregunta` se ubican en `com.kursor.core.domain`
- El core conoce directamente todos los tipos de pregunta
- Serializaci√≥n y gesti√≥n centralizada

#### Ventajas
- **Simplicidad inicial**: Estructura directa y f√°cil de entender
- **Cohesi√≥n del dominio**: Todas las entidades relacionadas est√°n juntas
- **Facilidad de serializaci√≥n**: Manejo unificado de persistencia
- **Referencias directas**: No requiere mecanismos de reflexi√≥n

#### Desventajas
- **Violaci√≥n del OCP**: El core debe modificarse para agregar nuevos tipos
- **Acoplamiento fuerte**: El core depende de implementaciones espec√≠ficas
- **Responsabilidad difusa**: El core se vuelve responsable de todos los tipos
- **Escalabilidad limitada**: El paquete domain crece indefinidamente
- **Dificultad de testing**: Dependencias complejas entre tipos

#### Evaluaci√≥n de Principios SOLID
- ‚ùå **SRP**: El core tiene m√∫ltiples responsabilidades
- ‚ùå **OCP**: Cerrado para extensi√≥n, abierto para modificaci√≥n
- ‚ùå **DIP**: Depende de implementaciones concretas
- ‚úÖ **LSP**: Se cumple (herencia correcta)
- ‚ùå **ISP**: El core conoce detalles de todos los tipos

### Opci√≥n 2: ***Arquitectura Modular***

#### Caracter√≠sticas
- Cada tipo de pregunta se define en su m√≥dulo correspondiente
- El core solo conoce la abstracci√≥n `Pregunta`
- M√≥dulos se cargan din√°micamente mediante ServiceLoader

#### Ventajas
- **Extensibilidad real**: Nuevos tipos sin modificar el core
- **Bajo acoplamiento**: El core solo depende de abstracciones
- **Responsabilidad √∫nica**: Cada m√≥dulo maneja su tipo espec√≠fico
- **Escalabilidad**: El core mantiene tama√±o constante
- **Desarrollo paralelo**: M√≥dulos independientes
- **Testing aislado**: Cada m√≥dulo se puede testear independientemente

#### Desventajas
- **Complejidad inicial**: Requiere patrones de dise√±o adicionales
- **Gesti√≥n de dependencias**: Mecanismos de carga din√°mica
- **Serializaci√≥n compleja**: Necesita factory pattern para instanciaci√≥n

#### Evaluaci√≥n de Principios SOLID
- ‚úÖ **SRP**: Cada m√≥dulo tiene una responsabilidad espec√≠fica
- ‚úÖ **OCP**: Abierto para extensi√≥n, cerrado para modificaci√≥n
- ‚úÖ **DIP**: Depende de abstracciones, no de implementaciones
- ‚úÖ **LSP**: Se cumple (herencia correcta)
- ‚úÖ **ISP**: Interfaces espec√≠ficas por m√≥dulo

## Decisi√≥n Arquitect√≥nica

Llegado este punto, resulta evidente que la decisi√≥n obvia y m√°s adecuada es elegir la ***Arquitectura Modular***.

**Justificaci√≥n:**

1. **Principios SOLID**: La *Arquitectura Modular* respeta todos los principios SOLID, mientras que la Opci√≥n 1 viola varios de ellos.

2. **Escalabilidad**: A largo plazo, el sistema puede crecer a 10+ tipos de preguntas sin afectar la estabilidad del core.

3. **Mantenibilidad**: Cada m√≥dulo se puede mantener, testear y desplegar independientemente.

4. **Extensibilidad**: Permite que terceros desarrollen m√≥dulos sin acceso al c√≥digo del core.

5. **Flexibilidad**: Diferentes m√≥dulos pueden tener diferentes licencias, versiones o dependencias.

## üèóÔ∏è **ESTRUCTURA ACTUAL IMPLEMENTADA**

### **M√ìDULO PRINCIPAL (kursor-core)**

#### **üìÇ ui/** - Interfaz de Usuario (2,147 l√≠neas total)
- **`KursorApplication.java`** (481 l√≠neas) - **Aplicaci√≥n principal JavaFX** que gestiona la ventana principal, pesta√±as, navegaci√≥n y toda la interfaz gr√°fica del sistema
- **`InspeccionarCurso.java`** (178 l√≠neas) - **Di√°logo modal** para mostrar informaci√≥n detallada de un curso (bloques, preguntas, estad√≠sticas)
- **`CursoDialog.java`** (478 l√≠neas) - **Di√°logo de gesti√≥n de cursos** para crear, editar y configurar cursos
- **`CursoSessionManager.java`** (277 l√≠neas) - **Gestor de sesiones de curso** que maneja el estado y progreso de las sesiones de aprendizaje
- **`PreguntaResponseExtractor.java`** (236 l√≠neas) - **Extractor de respuestas** que procesa y valida las respuestas de los usuarios a las preguntas
- **`EstadisticasDialog.java`** (72 l√≠neas) - **Di√°logo de estad√≠sticas** para mostrar m√©tricas de progreso y rendimiento
- **`AboutDialog.java`** (96 l√≠neas) - **Di√°logo "Acerca de"** con informaci√≥n de la aplicaci√≥n y cr√©ditos
- **`MenuBarExample.java`** (111 l√≠neas) - **Barra de men√∫** con opciones de navegaci√≥n y configuraci√≥n

#### **üìÇ domain/** - Modelo de Dominio (1,422 l√≠neas total)
- **`Curso.java`** (304 l√≠neas) - **Entidad principal** que representa un curso completo con sus bloques y metadatos
- **`Bloque.java`** (352 l√≠neas) - **Entidad de bloque** que agrupa preguntas relacionadas dentro de un curso
- **`Pregunta.java`** (170 l√≠neas) - **Entidad base de pregunta** con propiedades comunes para todos los tipos
- **`Sesion.java`** (707 l√≠neas) - **Entidad de sesi√≥n** que gestiona el estado de aprendizaje y progreso del usuario
- **`PreguntaSesion.java`** (41 l√≠neas) - **Entidad de pregunta en sesi√≥n** que mantiene el estado individual de cada pregunta
- **`EstrategiaAprendizaje.java`** (119 l√≠neas) - **Interfaz base** para estrategias de aprendizaje
- **`EstrategiaSecuencial.java`** (255 l√≠neas) - **Estrategia secuencial** que presenta preguntas en orden fijo
- **`EstrategiaAleatoria.java`** (263 l√≠neas) - **Estrategia aleatoria** que presenta preguntas en orden aleatorio
- **`EstrategiaRepeticionEspaciada.java`** (342 l√≠neas) - **Estrategia de repetici√≥n espaciada** basada en algoritmos de memoria

#### **üìÇ util/** - Utilidades y Gestores (811 l√≠neas total)
- **`ModuleManager.java`** (640 l√≠neas) - **Gestor de m√≥dulos** que carga y gestiona todos los m√≥dulos de tipos de preguntas
- **`CursoManager.java`** (171 l√≠neas) - **Gestor de cursos** que carga, valida y gestiona los archivos de cursos YAML

#### **üìÇ yaml/dto/** - Objetos de Transferencia de Datos
- **`CursoPreviewDTO.java`** (276 l√≠neas) - **DTO de vista previa** que contiene informaci√≥n resumida de cursos para la interfaz

#### **üìÇ service/** - Servicios
- **`CursoPreviewService.java`** (357 l√≠neas) - **Servicio de vista previa** que procesa y prepara datos de cursos para la UI

#### **üìÇ modules/** - M√≥dulos del Sistema
- **`PreguntaModule.java`** (94 l√≠neas) - **Interfaz base** para todos los m√≥dulos de tipos de preguntas

#### **üìÇ factory/** - Patr√≥n Factory
- **`PreguntaFactory.java`** (195 l√≠neas) - **Factory de preguntas** que crea instancias de diferentes tipos de preguntas

#### **üìÇ builder/** - Patr√≥n Builder
- **`CursoBuilder.java`** (300 l√≠neas) - **Builder de cursos** que facilita la construcci√≥n de objetos Curso complejos

### **üß© M√ìDULOS ESPEC√çFICOS DE TIPOS DE PREGUNTAS**

#### **üìÇ kursor-flashcard-module/** (320 l√≠neas total)
- **`FlashcardModule.java`** (116 l√≠neas) - **M√≥dulo de flashcards** que implementa el tipo de pregunta de tarjetas de memoria
- **`domain/Flashcard.java`** (204 l√≠neas) - **Entidad de flashcard** con pregunta, respuesta y metadatos espec√≠ficos

#### **üìÇ kursor-multiplechoice-module/** (586 l√≠neas total)
- **`MultipleChoiceModule.java`** (327 l√≠neas) - **M√≥dulo de opci√≥n m√∫ltiple** que implementa preguntas con m√∫ltiples opciones
- **`domain/PreguntaTest.java`** (259 l√≠neas) - **Entidad de pregunta test** con opciones, respuesta correcta y explicaciones

#### **üìÇ kursor-fillblanks-module/** (329 l√≠neas total)
- **`FillBlanksModule.java`** (125 l√≠neas) - **M√≥dulo de completar huecos** que implementa preguntas de rellenar espacios
- **`domain/PreguntaCompletarHuecos.java`** (204 l√≠neas) - **Entidad de pregunta de huecos** con texto con espacios y respuestas

#### **üìÇ kursor-truefalse-module/** (370 l√≠neas total)
- **`TrueFalseModule.java`** (117 l√≠neas) - **M√≥dulo de verdadero/falso** que implementa preguntas de tipo booleano
- **`domain/PreguntaTrueFalse.java`** (253 l√≠neas) - **Entidad de pregunta verdadero/falso** con enunciado y respuesta correcta

## üìä **ESTAD√çSTICAS DE IMPLEMENTACI√ìN**

### **Resumen de L√≠neas de C√≥digo**
- **Core Principal**: ~4,380 l√≠neas
- **M√≥dulos de Preguntas**: ~1,605 l√≠neas
- **Total del Sistema**: ~5,985 l√≠neas

### **Distribuci√≥n por Responsabilidad**
- **Interfaz de Usuario**: 36.7% (2,147 l√≠neas)
- **Modelo de Dominio**: 23.8% (1,422 l√≠neas)
- **Gesti√≥n y Utilidades**: 13.6% (811 l√≠neas)
- **M√≥dulos de Preguntas**: 26.8% (1,605 l√≠neas)

### **M√≥dulos Implementados**
1. ‚úÖ **Flashcard Module** - Tarjetas de memoria
2. ‚úÖ **Multiple Choice Module** - Preguntas de opci√≥n m√∫ltiple
3. ‚úÖ **Fill Blanks Module** - Completar huecos
4. ‚úÖ **True/False Module** - Preguntas verdadero/falso

## Patrones de Dise√±o Aplicados

### 1. Plugin Pattern
```java
// Interfaz del plugin
public interface PreguntaModule {
    String getTipoPregunta();
    Pregunta crearPregunta();
    // ... otros m√©todos
}
```

### 2. Factory Pattern
```java
// Factory para instanciar tipos din√°micamente
public class PreguntaFactory {
    public static Pregunta crearPregunta(String tipo, Map<String, Object> datos) {
        // L√≥gica de instanciaci√≥n basada en ServiceLoader
    }
}
```

### 3. ServiceLoader Pattern
```java
// Carga din√°mica de m√≥dulos
ServiceLoader<PreguntaModule> loader = ServiceLoader.load(PreguntaModule.class);
```

### 4. Strategy Pattern
```java
// Diferentes estrategias de renderizado por tipo
public interface PreguntaRenderer {
    Node renderizar(Pregunta pregunta);
}
```

### 5. Template Method Pattern
```java
// Clase abstracta Pregunta define el esqueleto
public abstract class Pregunta {
    public final void procesar() {
        validar();
        ejecutarLogicaEspecifica();
        persistir();
    }
    
    protected abstract void ejecutarLogicaEspecifica();
}
```

## Estructura de Paquetes Implementada

```
com.kursor.core.domain/
‚îú‚îÄ‚îÄ Pregunta.java (clase abstracta)
‚îú‚îÄ‚îÄ Bloque.java
‚îú‚îÄ‚îÄ Curso.java
‚îú‚îÄ‚îÄ Sesion.java
‚îú‚îÄ‚îÄ EstrategiaAprendizaje.java
‚îî‚îÄ‚îÄ ...

com.kursor.fillblanks/
‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îî‚îÄ‚îÄ PreguntaCompletarHuecos.java
‚îú‚îÄ‚îÄ FillBlanksModule.java
‚îî‚îÄ‚îÄ ...

com.kursor.multiplechoice/
‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îî‚îÄ‚îÄ PreguntaTest.java
‚îú‚îÄ‚îÄ MultipleChoiceModule.java
‚îî‚îÄ‚îÄ ...

com.kursor.flashcard/
‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îî‚îÄ‚îÄ Flashcard.java
‚îú‚îÄ‚îÄ FlashcardModule.java
‚îî‚îÄ‚îÄ ...

com.kursor.truefalse/
‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îî‚îÄ‚îÄ PreguntaTrueFalse.java
‚îú‚îÄ‚îÄ TrueFalseModule.java
‚îî‚îÄ‚îÄ ...
```

## Consideraciones de Implementaci√≥n

### 1. Gesti√≥n de Dependencias
- Los m√≥dulos deben tener acceso al core para heredar de `Pregunta`
- El core no debe tener dependencias hacia los m√≥dulos
- Uso de interfaces para comunicaci√≥n entre capas

### 2. Serializaci√≥n
- Implementar un sistema de DTOs para serializaci√≥n
- Usar factory pattern para reconstruir objetos desde DTOs
- Considerar formatos como JSON, YAML o XML

### 3. Carga Din√°mica
- ServiceLoader para detecci√≥n autom√°tica de m√≥dulos
- Validaci√≥n de m√≥dulos al cargar
- Manejo de errores de carga

### 4. Testing
- Tests unitarios por m√≥dulo
- Tests de integraci√≥n para el sistema completo
- Mocks para simular m√≥dulos en tests del core

## M√©tricas de Calidad

### Antes de la Refactorizaci√≥n
- **Acoplamiento**: Alto (core depende de implementaciones)
- **Cohesi√≥n**: Media (responsabilidades mezcladas)
- **Extensibilidad**: Baja (requiere modificar core)
- **Testabilidad**: Media (dependencias complejas)

### Despu√©s de la Refactorizaci√≥n
- **Acoplamiento**: Bajo (dependencias por abstracciones)
- **Cohesi√≥n**: Alta (responsabilidades bien definidas)
- **Extensibilidad**: Alta (nuevos m√≥dulos sin tocar core)
- **Testabilidad**: Alta (m√≥dulos independientes)

## Plan de Migraci√≥n

### ‚úÖ Fase 1: Preparaci√≥n (COMPLETADA)
1. ‚úÖ Definir interfaces y contratos
2. ‚úÖ Crear factory pattern base
3. ‚úÖ Implementar ServiceLoader

### ‚úÖ Fase 2: Refactorizaci√≥n (COMPLETADA)
1. ‚úÖ Mover clases existentes a m√≥dulos
2. ‚úÖ Actualizar referencias
3. ‚úÖ Implementar serializaci√≥n modular

### ‚úÖ Fase 3: Validaci√≥n (COMPLETADA)
1. ‚úÖ Tests de regresi√≥n
2. ‚úÖ Validaci√≥n de funcionalidad
3. ‚úÖ Documentaci√≥n actualizada

## üéØ **COMETIDOS POR CATEGOR√çA**

### **üèõÔ∏è Arquitectura Principal**
- **Aplicaci√≥n JavaFX** (`KursorApplication`) - Punto de entrada y gesti√≥n de la interfaz
- **Gestores** (`ModuleManager`, `CursoManager`) - Coordinaci√≥n del sistema
- **Servicios** (`CursoPreviewService`) - L√≥gica de negocio

### **üìä Modelo de Datos**
- **Entidades de dominio** (`Curso`, `Bloque`, `Pregunta`, `Sesion`) - Estructura de datos principal
- **Estrategias de aprendizaje** - Algoritmos para presentaci√≥n de contenido
- **DTOs** - Transferencia de datos entre capas

### **üé® Interfaz de Usuario**
- **Di√°logos modales** - Interacciones espec√≠ficas (inspecci√≥n, estad√≠sticas, configuraci√≥n)
- **Gesti√≥n de sesiones** - Control del estado de aprendizaje
- **Extractores de respuestas** - Procesamiento de entrada del usuario

### **üîß Patrones de Dise√±o**
- **Factory** - Creaci√≥n de tipos de preguntas
- **Builder** - Construcci√≥n de objetos complejos
- **M√≥dulos** - Extensibilidad del sistema

### **üß© Extensibilidad**
- **M√≥dulos de preguntas** - Tipos espec√≠ficos (flashcards, opci√≥n m√∫ltiple, huecos, verdadero/falso)
- **Cada m√≥dulo** incluye su implementaci√≥n y entidades de dominio espec√≠ficas

## Conclusiones

La arquitectura modular representa una inversi√≥n inicial mayor en complejidad, pero proporciona beneficios significativos a largo plazo:

- **Sostenibilidad**: El c√≥digo ser√° m√°s f√°cil de mantener
- **Escalabilidad**: El sistema puede crecer sin l√≠mites
- **Flexibilidad**: Adaptaci√≥n a nuevos requerimientos
- **Calidad**: C√≥digo m√°s limpio y testeable

Esta decisi√≥n alinea el sistema Kursor con las mejores pr√°cticas de arquitectura de software y prepara el terreno para un crecimiento sostenible del proyecto.

**‚úÖ IMPLEMENTACI√ìN EXITOSA**: La arquitectura modular ha sido completamente implementada y est√° funcionando en producci√≥n con 4 m√≥dulos de tipos de preguntas diferentes, demostrando la viabilidad y beneficios del enfoque elegido.

---

**Documento preparado por:** *Juan Jos√© Ruiz P√©rez <jjrp1@um.es>*  
**Fecha:** 19/06/2025  
**Versi√≥n:** 2.0  
**Estado:** ‚úÖ **IMPLEMENTADO Y EN PRODUCCI√ìN** 